[package]
name = "omniglot"
version.workspace = true
authors.workspace = true
edition.workspace = true
rust-version.workspace = true

[features]
default = ["std", "runtime_id"]

# Enable features only available with full standard library support. This
# includes:
# - a heap allocator backend for MockRt (useful for platforms that don't have
#   stack frame allocator assembly written)
std = []

# Add support for the `RuntimeBranding` Omniglot ID type, which assigns
# runtime-checked IDs using a global AtomicU64. This can allow multiple Omniglot
# runtimes to share an identical type signature. However, it requires support
# for atomics, and thus we make it an optional, opt-in feature:
runtime_id = []

# Enable features only available when compiling on a nightly toolchain. This is
# a flag for features that are "unconditionally better" and which do not
# influence the overall behavior of the library meaningfully. Configuration
# options that don't meet these constraints should get their own feature flags.
#
# As of now, this includes:
# - generating #[doc(cfg( attributes to document that some items are only
#   available when certain features are selected:
nightly = []

# Dangerous flags, for evaluation purposes only. Setting either of these flags
# requires the `unsound` feature flag. We don't enforce this dependency here,
# instead we produce a compile error when it is not set.
unsound = []
disable_upgrade_checks = []
disable_validation_checks = []

# Turning on this feature enables an optimization where OG* references created
# against a given `AllocScope` reference can outlive the lifetime of that
# `AllocScope` reference, and instead only be bound to the lifetime of the
# closure by which this new `AllocScope` was issued (described in the OSDI'25
# paper at the end of section 4.4).
#
# This optimization relies on the fact that the host has exclusive control over
# the memory regions accessible to foreign code, and is able to dereference any
# memory accessible to foreign code. When enabling "foreign code protection"
# (where a library can itself govern which regions in its memory it wants host
# code to have access to), this optimization does not work: any call into the
# library may invalidate any prior OG* references.
#
# Thus, runtimes that implement such "foreign code protection" must only make
# that mode available when this feature is not enabled. They can query whether
# it is enabled using the `omniglot::ALLOC_SCOPE_SEPARATE_ACTIVE_VALID_LT`
# public constant.
alloc_scope_separate_active_valid_lt = []

[dependencies]
seq-macro = "0.3.6"